# Data Visualization with ggplot2 {#ggplot2}

## Introduction

The first thing to do is to plot the data in the epidemiologic data analysis task. Data visualization enables many features of the data to be displayed or summarized in a graphical format, including patterns, changes over time, unusual observations, relationships among variables, and spatial variations. The features that are seen in graphs of the data must then be incorporated as much as possible into the modeling or forecasting methods. 

There are many types of graphs available, each with its own strengths and use cases. One of the challenges in the statistical learning process is choosing the appropriate visualization method to represent the data. Before constructing any display of epidemiologic data, it is important to understand the type of task that we want to perform and determine the information to convey. Some common roles for data visualization include:

* highlighting a change from past patterns in the data;
* displaying a part-to-whole composition;
* showing how data is distributed;
* showing a difference or similarity between groups;
* displaying the spatial variation in geographical data;
* illustrating relationships among variables.

When the data is more complex, visualize broader patterns with graphs. Graphs can also visualize trends as well as identify variations from those trends. Variations in data may represent important new findings or could just be errors in typing or coding that need to be corrected. Thus, graphs can be helpful tools to aid in verifying and analyzing the data. Once an analysis is complete, graphs further serve as useful visual aids for describing the data to others. 

This chapter will introduce the `ggplot2`, and we will gain insight and practical skills for visualization of infectious disease data.


Recommended Reading: 

1. https://ggplot2.tidyverse.org
2. https://opr.princeton.edu/workshops/Downloads/
3. https://ggplot2-book.org/introduction.html


`ggplot2` builds on [Leland Wilkinson’s The Grammar of Graphics](https://stanford.idm.oclc.org/login?url=http://www.myilibrary.com?id=46066) and focuses on the primacy of layers and adapts it for R.

>In brief, the grammar tells us that a graphic maps the data to the aesthetic attributes (color, shape, size) of geometric objects (points, lines, bars). The plot may also include statistical transformations of the data and information about the plot’s coordinate system. Facetting can be used to plot for different subsets of the data. The combination of these independent components is what makes up a graphic.

In this chapter, we will introduce the basics of `ggplot2` grammar and some of the key features, including the use of `geom`, `stat`, `scale`, `coord`,  and `facet`.

## Types of Variables and Preparation

Keep in mind that the primary purpose of preparing graphs is to communicate information. The types of variables we are analyzing and the media for the visualization can also affect your graphics practice.

### Types of Variables

When examining data, you must know which data type you are working with in order to choose an appropriate display format. The data are most likely going to be in one of the following categories:

1. Categorical (Qualitative) variables

* A **nominal** variable is one whose values are categories without any numerical ranking. Good examples are occupation, place of birth, county of residence and diagnosis. Nominal variable is called **dichotomous** when it is characterised by only two classes. In epidemiology, it is common to see  dichotomous variables: sex (male/female), exposure history (yes/no), alive or dead, ill or well, vaccinated or un-vaccinated. 

* An **ordinale** variable has values that can be ranked but are not necessarily evenly spaced. For example, severity of illness may be categorized and ordered as "mild", "moderate" or "severe".

2. Numerical (Quantitative) variables

There are two types of **quantitative** variables: 

* **Discrete** variables have values that are distinct and separate. Discrete data can't be measured but can be counted. 
For example, the number of new cases of a certain disease in a given year.

* **Continuous** variables represents measurements and can have any value in a range. Examples of continuous data would be the amount of the time period between when you catch a virus and when your symptoms start. Discrete data can't be counted but can be measured.

* An **interval-scale** variable is measured on a scale of equally spaced units, but without a true zero point. An example of interval data is date of birth.

* A **ratio-scale** variable is the same as interval values, with the difference that they do have an absolute zero. Good examples are be height in centimeters or duration of illness.

### Rules for Graph Designing

When designing graphs, we need to follow some rules to achieve the best practices, and @dicker1992principles suggests the following:

* Check to ensure that a graphic can stand alone by clearly labeling the title, sources, axes, scales, and legends;

* Identify variables portrayed (legends or keys), which includes units of measure;

* Minimize the number of lines on a graph;

* Generally, we portray frequency on the vertical scale, starting at zero while we portray classification variable on the horizontal scale;

* Check to ensure that the scales for each axis are appropriate for data presented;

* Define any abbreviations or symbols

* Specify any data excluded.

### Installing packages and loading data

Before we begin, please get ready by installing the `ggplot2` package by any of the following method.

```{r, eval = F, warning=FALSE, message=FALSE}
# The easiest way to get ggplot2 is to install the whole tidyverse:
install.packages("tidyverse")

# Alternatively, install just ggplot2:
install.packages("ggplot2")

# Or the development version from GitHub:
# install.packages("devtools")
devtools::install_github("tidyverse/ggplot2")
```

**Note:** `devtools` downloads and installs the package from GitHub. By default, `install.packages()` is only able to install packages that are available in Comprehensive R Archive Network (CRAN). In that case, the developer's tool, `devtools::install_github()` enables users to install packages that have not been submitted to CRAN, but is available in GitHub.

In addition, we need to library the required packages as following.

```{r, echo = F, include=F, warning=FALSE, message=FALSE}
library(ggplot2)
library(dplyr)
```

In the rest of this section, we demonstrate how to create a basic scatter plot and output the figure in “png” and “rds” format. To create a `ggplot2` plot, we need to know three key components:

* (1) A dataframe with each column being an attribute/variable, each row being an individual; 

* (2) A set of aesthetic mappings between variables in the data and visual properties. 

* (3) At least one layer which describes how to render each observation. Layers are usually created with a `geom` function.

“ggplot” generally prefers data in the “long” format: i.e., a column for every dimension, and a row for every observation. For illustration, we are going to use the `state.long` data set in the R package `slid`. To prepare the data, install the R package `slid` from Github using the following command, which includes the data sets that we use for this book. 

```{r data_prep, echo = F, include=F, warning=FALSE, message=FALSE}
# Obtain the data demonstrated in the chapter
library(slid)
# devtools::install_github('https://github.com/covid19-dashboard-us/slid')
```

Open the `state.long` dataset, which includes the variables, cumulative infected cases (`Infected `), cumulative death counts (`Death`), `Region`, `Division`, `State`, population (`pop`), and `DATE`, starting from Jan 22, 2020. Take a look at the first few lines using `head()`.

```{r eval = T}
df <- slid::state.long

head(df)
```

### Your first scatterplot

Here we introduce how to draw a simple scatter plot using the data of ‘2020-12-11’. Treat `log(Infected)` as the x-axis, and `log(Death)` as the y-axis. We create it by telling “ggplot” the data `df`, the aesthetic mapping `aes(log(Infected), log(Death))`, and the layer `geom_point()`. The structure `ggplot() + geom_point()` is the typical way to create a plot, in which “ggplot” is told the data and mapping, and `geom_point` is a layer of a picture using the information embedded in “ggplot”. Later in this chapter, you will see how we can use `+` to assign additional adjustments and add multiple layers to the existing figure. 


```{r ggplotscatter1, out.width='50%', fig.align='center',fig.cap="Scatterplot of log cumulative death against log cumulative infected"}
# Select the date
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 

# Create scatter plot
# Data: df
# Aesthetic: first mapped to x, second mapped to y
# Layer: render the plot as a scatterplot
p <- ggplot(df, aes(log(Infected + 1), log(Death + 1)))
p + geom_point()         
```

**Remarks:**

In the above example, the dataframe `df` is the first parameter in the above `ggplot()`, and aesthetics are defined within an `aes()` function. We need to place `+` at the end of the previous line instead of the beginning of new line.

**Aesthetics** are properties of the plot that can show certain elements of the data. The following is a list of some common plot aesthetics you might want to specify in your `geom_point()`:

* `x`: position on x-axis
* `y`: position on y-axis
* `alpha`: transparency (1: opaque; 0: transparent)
* `color`: color of border of elements
* `fill`: color of inside of elements
* `shape`: shape
* `group`: group 
* `size`: size
* `stroke`: border size of points

We will explain more details in the following sections. 

## Position Scales and Axes

### Change the labels of the axis using `xlab()` and `ylab()`

See Figure \@ref(fig:xlabggplot) for the customized labels and title.

```{r xlabggplot, out.width='50%', fig.align='center', fig.cap= 'Scatterplot with customized lables and title'}
# Change the transparency using alpha
p <- p + geom_point(alpha = 0.7) + 
   # Change the label of horizontal axis
  xlab('log Infected') +
  # Change the label of vertical axis
  ylab('log Death') + 
  # Change the title
  labs(title = 'Log death against infected cases in US')
p
```

<!-- ### Reverse the scale 

We can use `scale_x_reverse()` and `scale_y_reverse()` to change the order of the values on axis. -->

```{r, fig.show = 'hold', out.width= '50%', fig.cap='Scatterplot with reversed order of values on axis'}
#p + scale_x_reverse()
#p + scale_y_reverse()
```

### Change the range of the axis using `xlim()` and `ylim()`

For continuous variables, we can provide the lower and upper limits. For categorical variables, we can provide the names of categories desired. To suppress the warning “Removed XXX rows containing missing values”, use `na.rm`. This needs to be carefully used because the data outside the range are converted to `NA`, which will affect later manipulations, such as calculating the mean or sum.

```{r xlimggplot,fig.show="hold", out.width="50%",fig.align='center', fig.cap='Scatterplot with customized axis range for continuous features'}
# For continuous variable, provide the lower and upper limits
p <- p + geom_point() + ylim(4, 12) 
p
```

```{r xlimggplot2,fig.align = 'center', out.width="50%", fig.cap='Scatterplot with customized axis range for discrete features'}
# For discrete variable, provide the names of categories desired
# To suppress the warning 'Removed XXX rows containing...', use `na.rm`. 
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 

ggplot(df, aes(Region, log(Death + 1))) + 
  geom_point(na.rm = TRUE) +
  xlim('West', 'Midwest', 'South') 
```


## Color Scales and Size of `geom_points()`

There are two ways of coloring. One approach is to color all points with the same color. The other method is to color the points according to a particular feature of the observation.

### Change the color of all points

```{r eval = T, out.width='50%', fig.align='center', fig.cap='Scatterplot with all points colored blue'}
p + geom_point(color = "blue")
```

### Color the observations by the value of a feature

```{r, out.width='50%', fig.show = 'hold', fig.cap='Scatterplot with points colored by Region or Population'}
# Use Region as the feature for coloring
p + geom_point(aes(color = Region)) 
# p + aes(color = Region) 

# Use population for coloring
p + geom_point(aes(color = pop))
```

**Remarks:** the `color` feature is located at different layers in three figures. In the first figure, it is under `geom_point()`, while in the latter two figures it is under `geom_point(aes())`. Because we only have one layer in this example, we can equivalently use `aes()`, i.e., the aesthetic mapping for the whole scatterplot.


### Change the color palette

In addition, we can personalize the color palette using `scale_fill_brewer()` for a discrete color scale, and `scale_fill_distiller()` for a continuous color scale.

```{r, out.width='50%', fig.show = 'hold', fig.cap='Scatterplot with customized color palette'}
# Change the palette
# For discrete scale
p + geom_point(aes(color = Region)) + 
   scale_fill_brewer(palette = "Set1", aesthetics = "color")
# For continuous scale
p + geom_point(aes(color = pop)) +
 scale_fill_distiller(palette = 2, aesthetics = "color")
```

### Change the size by the value of a feature

```{r, out.width='50%', fig.show = 'hold', fig.cap='Scatterplot with customized point size or color'}
p <- ggplot(df, aes(log(Infected + 1), log(Death + 1))) +
  xlab('log Infected') +
  ylab('log Death') + 
  labs(title = 'Log death against infected cases in US')

# Change the point size
p + geom_point(aes (size = pop))

# Change the point color and size
p + geom_point(aes (size = pop , color = pop))

```

```{r, out.width='50%', fig.show = 'hold', fig.cap='Scatterplot with customized point color and point size'}
# Combine the color and size in legend
# Method 1: keep the size and color the same limits and breaks
p + geom_point(aes (size = pop, color = pop)) +
  scale_color_continuous(limits = c(0e7, 4e7), 
                         breaks = seq(0, 4e7, by = 1e7)) +
  scale_size_area(limits = c(0e7, 4e7), 
                  breaks = seq(0, 4e7, by = 1e7), max_size = 12) +
  guides(color = guide_legend(), size = guide_legend()) 

# Method 2: use scale_color_gradient and scale_size
p <- p + geom_point(aes(size = pop, color = pop), alpha = 0.7) +
   scale_color_gradient(low = "lightblue", high = "red") +
   scale_size_area(max_size = 12) +
   guides(color = guide_legend(), size = guide_legend())

p
```

**Remarks:** For Method 1, the key to combining two aesthetic settings of the layer to one legend, in this case, `color` and `size`, is to set the `limits` and `breaks` to be the same in `guides`. For both methods, `guides(color = guide_legend(), size = guide_legend())` is needed.

## Individual geoms 

Apart from the scatter plot, there are many individual geoms, for example:  

* `geom_line()`: line graphs
* `geom_boxplot()`:boxplots
* `geom_bar()`: bar chart
* `geom_histogram()`: histogram plots
* `geom_smooth()`: regression lines or curves

We introduce a few of them in detail as follows.

<!-- ### Path, line and step plots -->

<!-- It is important to note there are three line and step plotting functions we can use. -->

<!-- > - Line plots, `geom_line()` connects them in order of the variable on the x axis.  -->
<!-- > - Path plots, `geom_path()` connects the observations in the order in which they appear in the data. -->
<!-- > - Step plots, `geom_step()` creates a stairstep plot, highlighting exactly when changes occur.  -->

<!-- ```{r Timeseries3, fig.show="hold", out.width="33%", fig.cap='Line plot, path plot and step plot examples'} -->
<!-- d <- as.Date('2020-12-11') -->
<!-- df <- slid::state.long %>%  -->
<!--   dplyr::filter(DATE == d)  -->
<!-- p <- ggplot(df, aes(pop, Infected)) + -->
<!--   labs(title = 'Cum. Infected vs population on 2020-12-11') -->
<!-- p + geom_line() -->
<!-- p + geom_path() -->
<!-- p + geom_step() -->
<!-- ``` -->

### Histogram

The histogram is an important tool to summarize the range and frequency of observations. Here we plot the histogram of log daily new infected cases counts using using `geom_histogram`. We can adjust the option `binwidth` to control the widths of the bins.

```{r Histogram, fig.show="hold", out.width="50%", fig.cap='Histogram examples'}
# Prepare the daily new Infected for each state 
# in the period 2020-11-12 to 2020-12-11
df <- slid::state.long %>% 
  dplyr::filter(DATE <= '2020-12-11' & DATE > '2020-11-11') %>%
  group_by(State) %>% # Group by State
  mutate(Y.Infected = 
           c(Infected[-length(Infected)] - Infected[-1], 0)) 
df

p <- ggplot(df, aes(log(Y.Infected + 1))) 
p + geom_histogram(binwidth = 1)
p + geom_histogram(binwidth = 1) + aes(fill = Region) 
```

### Bar chart

The discrete analogue of histogram is the bar chart. 

### Default bar chart

The default `geom_bar()`, or equivalently `geom_bar(stat='count')`, counts the number of observations in each category shown as following. This plot essentially tells us how many states there are in each region.

```{r Boxplot1, fig.align='center', out.width="50%", fig.cap='Bar plot example'}
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 
p <- ggplot(df, aes(Region))
p + geom_bar()
```

### Bar chart with assigned value

In addition to the previous example, we can assign the height of the bars by ourselves by using the option `geom_bar(stat = 'identity')`. In that case, we tell `geom_bar` to use `y` value in the data frame as the height of the bars.

```{r Boxplot2,fig.show = 'hold', out.width="50%", fig.cap='Bar plot with assigned values'}
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 
p <- ggplot(df, aes(Region, Infected)) 
p + geom_bar(stat = 'identity') 
p + geom_bar(stat = 'identity', aes(fill = Division))
```

### Legend

1. Legend position

We can adjust the position of the legends using `theme(legend.position = 'left/right/bottom/none')`.

```{r, out.width='50%', fig.align='center', fig.cap='Scatterplot with legend at bottom'}
p <- ggplot(df, aes(Region, fill = Region)) +
  ylab('Number of states') + 
  geom_bar()

p + theme(legend.position = 'bottom')
```

2. Legend guide `guide_legend()`

We can also assign individual keys to the legend using options of `guide_legend()`. Here we introduce the most useful options. 

* `nrow` and `ncol`: specify the dimensions of the table. `byrow`: fills the rows, set to `FALSE` by default.

```{r, out.width='50%', fig.align='center', fig.show='hold', fig.cap='Bar plots of number of states in each region'}
p + guides(fill = guide_legend(ncol = 2, byrow = TRUE))
```

* `reverse`: reverse the order of the keys

```{r, out.width='50%', fig.align='center', fig.show='hold', fig.cap='Bar plots of number of states in each region'}
p + guides(fill = guide_legend(reverse = TRUE))
```


### Boxplots, jittering and violin plots

Conditioning on a categorical feature, or conditioning on groups, we may want to conduct a side-by-side comparison for a certain variable. We can use the following tools.

> - Jittering, `geom_jitter()`, adds a small amount of random noise to the data, which can help avoid over-plotting.
> - Boxplots, `geom_boxplot()`, summarizes the shape of the distribution with summary statistics.
> - Violin plots, `geom_violin()`, shows a compact representation of the “density” of the distribution and highlights the areas where more points are found.

```{r Boxplot3, fig.show="hold", out.width="50%", fig.cap='Points, jittering, boxplot, and violin plot examples'}
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) %>%
  mutate(Risk = Infected / pop)

p <- ggplot(df, aes(Region, Risk, color = Region)) 
p + geom_point()
p + geom_jitter()
p + geom_boxplot()
p + geom_violin()
```


## Collective geoms

An individual “geom” can draw a distinct graphical object for each observation (row). For example, the “point geom” draws one point per row. 
Several "geoms" may be added to the same ggplot object, which will let you build layers to design complex graphs as well as displays multiple observations with one geometric object. For example, we have previously created a scatter plot, and then we can add regressed lines on the top of the scatter plot layer. You can add more information from a statistical summary, or add a text geom to annotate your plot. 

### Smoother

On top of the scatter plot, we can add regressed lines and prediction band to it using `geom_smooth()`.

1. The “loess” method

By default, the model for small data is “loess”, we can call the layer either by `geom_smooth()` or `geom_smooth(method ='loess')`. In addition, we can adjust option `span` to control the wiggliness of the line. The higher `span` is, the less wiggle the line will be.

```{r eval = T, out.width='50%', fig.show='hold', message=FALSE, fig.cap='loess smoother examples'}
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 
p <- ggplot(df, aes(log(Infected + 1), log(Death + 1))) +
  geom_point()
# Use `span` to control the wiggliness of the line
# The higher `span` is, the less wiggle the line is
p + geom_smooth(method = 'loess', span = 0.5) 
p + geom_smooth(method = 'loess', span = 1) 
```

2. Linear regression method

We can also use `method = 'lm'` to fit a simple linear model:
<!-- , and use `method = 'gam', formula = y ~s(x)` to fit a generalized additive model. -->

```{r eval = T, out.width='50%',fig.show='hold',message=FALSE, fig.cap='Linear regression estimator.'}
# Fit a linear model
p + geom_smooth(method = 'lm')  
```

After introducing the idea of individual and collective geoms, we would like to spend the rest of the chapter discussing two important collective plots, time series plots and maps. We will build them step by step from scratch.


## Time Series

### Basic line plots

In traditional time series plots, we use time as the x-axis variable, and plot the time series using `geom_line()`.

We consider the time series of the daily new infected count for Iowa. 

```{r, warning=FALSE, message=FALSE}
df <- slid::state.long %>%
  dplyr::filter(State == "Iowa") %>%
  arrange(DATE) %>%
  mutate(Y.Infected = Infected - lag(Infected)) %>%
  dplyr::filter(!is.na(Y.Infected))
```

To visualize the data, we draw a time series plot first. 

```{r Timeseries2, fig.show="hold", out.width='80%', fig.align='center', fig.cap='Basic time series'}
p <- ggplot(df, aes(DATE, Y.Infected)) + 
  geom_line() + 
  labs(x = "Days", y = "Count", 
       title = 'Daily new infected cases in Iowa') 
p
```

### Add a second line

Next, we display the prediction results on the time series plot. The prediction and prediction intervals for the next 14 days are saved in the dataset: `slid::fore`.

```{r, eval=FALSE, warning=FALSE, message=FALSE}
# Data Preparation
if(!require('lubridate')) install.packages('lubridate')
```

```{r, warning=FALSE, message=FALSE}
library(lubridate)
df.pred <- as.data.frame(slid::fore[c('mean', 'lower', 'upper')])
names(df.pred) <- c('mean', 'lower', 'upper')
df.pred$DATE <- tail(df$DATE,1) + 
  c(1:length(slid::fore$mean))
```

```{r tspred0, fig.show="hold", out.width='100%', fig.align='center',fig.cap='Time series with added predictions'}
# Add a line for predicted value
p + geom_line(mapping = aes(x = DATE, 
                            y = mean,
                            color = 'Predicted Value'),
              linetype = "dashed",
              # Set the line type in legend
              key_glyph = "timeseries",
              data = df.pred) + 
  scale_color_manual("", values = "red")
```

### Add ribbons

Next, we show the prediction intervals. On top of the line plots, we can add another layer to the existing line, and create a line with two parts. 

```{r tspred, fig.show="hold", out.width='100%', fig.align='center', fig.cap='Time series with ribbons and second line'}
# Add prediction intervals
p <- p + 
  geom_ribbon(mapping = aes(x = DATE, 
                            y = mean, 
                            ymin = lower, 
                            ymax = upper,
                            fill = '95% Prediction Intervals'), 
              data = df.pred, alpha = 0.2) + 
# Add line for predicted value
geom_line(mapping = aes(x = DATE,
y = mean,
color = 'Predicted Value'),
linetype = "dashed", data = df.pred,
# Set the line type in legend
key_glyph = "timeseries") +
scale_color_manual("", values = "red")+
scale_fill_manual("", values = "pink")

p
```

**Remarks:** the layer added later is put on the top, therefore it is important to keep track of the order you add the layers.

### Adjust the scale of time axis

There are multiple ways to define the ticks on the axis of dates and times. There are the labeled **major breaks** and further the **minor breaks**, which are not labeled but marked by grid lines. These can be customized with the arguments `date_breaks` and `date_minor_breaks`, respectively. 

```{r, out.width='100%', fig.align='center', warning=FALSE, message=FALSE, fig.cap='Time series plot with adjusted time range and format'}
# Adjust the scale of time axis
p + scale_x_date(
  limits = as.Date(c("2020-10-01", "2021-01-01")),
  date_breaks = "1 month",
  date_minor_breaks = "1 week",
  date_labels = "%B %Y"
)
```

In the above syntax, `date_labels` set to a string of formatting codes, defining order, format and elements to be displayed:

* `%d`:	day of the month (01-31)
* `%m`:	month, numeric (01-12)
* `%b`:	month, abbreviated (Jan-Dec)
* `%B`:	month, full (January-December)
* `%y`:	year, without century (00-99)
* `%Y`:	year, with century (0000-9999)

### Add annotations

It is often necessary to make annotations to the data displayed when constructing a data visualization. An annotation provides additional information around what data is being displayed. For example, adding text to a plot is one of the most common forms of annotation. The primary tool for labeling plots is `geom_text()`, which adds label text at the specified `x` and `y` positions. We can also add reference lines to the plot using `geom_vline` or `geom_hline`. Figure \@ref(annotate1) shows an annotated time series plot with shades and reference lines for each quarter.

```{r annotate1, out.width='100%', fig.align='center', fig.cap='Time series plot with shades and reference lines.'}
# Prepare the data
df <- df %>%
  mutate(start = floor_date(DATE, "quarter")) %>%
  mutate(end = ceiling_date(DATE, "quarter")) %>%
  mutate(quarters = as.factor(quarter(DATE))) 
  
df.quarters <- df %>% 
  dplyr::select(start, end, quarters) %>%
  unique()

# Draw the base ggplot
ggplot(df, aes(DATE, Y.Infected)) +
  labs(x = "Days", y = "Count", 
       title = 'Daily new infected cases in Iowa') +
  
  # Add rectangle for each quarter
  geom_rect(
    aes(xmin = (start), xmax = (end), fill = quarters),
    inherit.aes = F, ymin = -Inf, ymax = Inf, 
    alpha = .5, data = df.quarters) + 
  scale_fill_brewer(palette = "Blues", aesthetics = "fill") +
  
  # Add vertical line
  geom_vline(aes(xintercept = as.numeric(start)), 
    data = df, color = "gray",
    linetype = 'dashed', size = 0.5) + 
  
  # Add text
  geom_text(
    aes(x = start, y = 0 , label = paste0('Quarter:', quarters)), 
    data = df.quarters, inherit.aes = F,
    size = 3, vjust = 0, hjust = 0, nudge_x = 20) +
  
  # Add time series lines
  geom_line() +
  geom_line(mapping = aes(x = DATE, y = mean,
                          color = 'Predicted Value'),
            linetype = "dashed", data = df.pred ,
            key_glyph = "timeseries") 
```

## Maps

In epidemilogy, data often  includes geographical information such as latitude and longitude or regions like country, state or county. To plot these types of data, we can extend an existing visualization onto a map background. We will learn how to make choropleth maps, sometimes called heat maps, using the `ggplot2` package. A **choropleth map** is a map that shows a geographic landscape with units such as countries, states, or watersheds where each unit is colored according to a particular value.

```{r, eval=TRUE, collapse=FALSE}
# Read map and data
library(ggplot2)
library(maps)
library(dplyr)

# Load United States state map data
MainStates <- map_data("state")
head(MainStates, 3)

MainStates <- MainStates %>%
  mutate('state' = gsub(' ', '', MainStates$region)) %>%
  select(-c('region','subregion'))
head(MainStates, 3)

state.long.shape <- slid::state.long %>% 
  mutate('state' = tolower(slid::state.long$State)) %>%
  right_join(MainStates, by = 'state') %>%
  select(-state)
state.long.shape

df <- state.long.shape %>% 
  dplyr::filter(DATE == '2020-12-11')  %>% 
  mutate (Risk = Infected / pop * 1000)
```


### Making a base map

Using `qplot()`, we can obtain our first map like this:

```{r, eval=TRUE, out.width='75%', fig.align='center', fig.cap='Basic US map with dotted state boundaries'}
qplot(long, lat, geom = "point", data = df)
```

We can use the `geom_polygon()` function to create a map with black borders and add light blue to fill in the map.

```{r, eval=TRUE, out.width='75%', fig.align='center', fig.height = 4, fig.width = 7, fig.cap='US map with colored state areas'}
# Plot all states with ggplot2, black borders and light blue fill
ggplot() + 
  geom_polygon(data = df, 
               aes(x = long, y = lat, group = group),
                color = "black", fill = "lightblue")
```

### Customizing `choropleth` map

Now that we have created a base map of the mainland states, we will color each state according to its the risk. Make the use of `slid::ggplot_map_state` dataset.


```{r, eval=TRUE, out.width='100%', fig.align='center', fig.height = 3.5, fig.width = 7, fig.cap='US map with colored state areas according to infected per thousand population'}
# Create a Choropleth map of the United States
p <- ggplot() + geom_polygon(data = df, 
          aes(x = long, y = lat, group = group, 
              fill = Risk), 
          color = "white", size = 0.2) 
p
```

**Remarks**

* Each state is colored by “Infected per 1000 people” to make the legend easier to read.

* Border color (`white`) and line thickness (`size = 0.2`) are specifically defined within this `geom_polygon()`.


Once a map is created, it is often helpful to modify color schemes, determine how to address missing values (`na.values`), and formalize labels. Notice that we assigned the graph a name, `p`. This is particularly useful as we add new components to the map.


```{r, eval=TRUE, fig.align='center', fig.height = 3.5, fig.width = 7, fig.cap='US map with colored state areas with limits on the values'}
p + scale_fill_continuous(name = "Infected per 1000 pop",
                          low = "yellow", high = "darkred",
                          limits = c(0, 125), 
                          breaks = c(5, 25, 50, 75, 100, 125), 
                          na.value = "grey50") +
  labs(title = "Infected per 1000 population on 2020-12-11")
```

### Overlay polygon maps

It is also possible to overlay two polygon maps. The code below creates county borders with a small line size and then adds a thicker line to represent state borders. The `alpha = .3` causes the fill in the state map to be transparent, allowing us to see the county map behind the state map.

```{r, eval=TRUE, fig.align='center', fig.height = 3, fig.width = 5, fig.cap='US map with colored state areas and county boundaries'}
ggplot() + geom_polygon(data = map_data("county"), 
                aes(x = long, y = lat, group = group),
                color = "darkblue", 
                fill = "lightblue", size = .1) + 
  
            geom_polygon(data = map_data('state'), 
                       aes(x = long, y = lat, group = group),
                color = "black", fill = "lightblue",  
                size = .5, alpha = .3) 
```


## Arranging Plots

### Facet

Sometimes, we wish to look that the scatterplot within each factor of categorical variables. For example, we may want to look at the situation within each `Region` in our case. We can split a single plot into many related plots using the function `facet_wrap()` or `facet_grid()`:

* `facet_wrap(~variable)` will return a symmetrical matrix of plots for the number of levels of variable;

* `facet_grid(. ~variable)` will return facets equal to the levels of variable distributed horizontally. 

* `facet_grid(variable~.)` will return facets equal to the levels of variable distributed vertically.


```{r, out.width='75%', fig.align='center', fig.cap='Facetting examples'}
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 
p <- ggplot(df, aes(log(Infected + 1), log(Death + 1))) + 
  geom_point(na.rm = TRUE) +
  aes(color = Region) 

p
p + facet_grid(.~Region)
p + facet_grid(Region~.)
p + facet_wrap(~Region)
```


### Combining plots using `patchwork` package

Before plots can be laid out, they have to be assembled. The goal of `patchwork` is to make it simple to combine separate ggplots into the same graphic. We can install patchwork from CRAN using

```{r eval=T, warning=FALSE, message=FALSE}
if (!require('patchwork')) install.packages('patchwork')
library(patchwork)
```

Let us consider some simple examples.

```{r, out.width='75%', fig.align='center',  fig.cap='Patchwork examples'}
df  <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-12-11')) 
p1 <- ggplot(df, aes(log(Infected+1), log(Death + 1))) + 
  geom_point(na.rm = TRUE) 

p2 <- ggplot(df, aes(log(Death + 1))) + 
  geom_histogram(binwidth = 1) + aes(fill = Region) 

p3 <- ggplot(df, aes(log(Infected + 1))) + 
  geom_histogram(binwidth = 1) + aes(fill = Region) 

# Horizontal arrangement
p1 + p2
# Vertical arrangement
p1 / p2
# Grouped arrangements
p1 | (p2 / p3)

# Combine three plots
p1 + p2 + p3 

# Set the number of plots per row
p1 + p2 + p3 + plot_layout(ncol = 2)

# Combine the duplicate legends
p1 + p2 + p3 + plot_layout(ncol = 2, guides = "collect")

# Add title and subtitles
p123 <- (p1 | (p2 / p3))+ plot_annotation(
  title = "Add title here",
  caption = "Add caption here"
)
p123
```


## Output

After polishing the figure, we need to save the figure and output it as a readable file for later use. We can either output it in a standard figure format, such as png, tiff, jpeg; or we can save it as an R readable data file, usually referred to as `XXX.rds`, `XXX.rda` or `XXX.RData`, and read by `readRDS('XXX.rds')`. 

### Save in figure format

```{r output_ggplot, fig.align='center'}
# Take a look at the figure before saving
# print(p) 
ggsave('example_ggplot2.png', p) # Save the figure in png format
```

### Save in RDS format

```{r output_rds_ggplot, fig.align='center'}
# Save the figure in .rda format
saveRDS(p, 'example_ggplot2.rds') 
# Read the figure in .rda format
q <- readRDS('example_ggplot2.rds')
# print(q)
```


## Exercises

1. Scatter plot using `slid::state.long` on 2020-11-01. 
  a. Create a scatter plot. Treat `Infected/1000` as x-axis, and `Death/1000` as y-axis.
  b. Color the points according to `Division`. Hint: use `aes(color = )`.
  c. Change the size of the points to be proportional to population. Hint: use `aes(size = )`.
  d. Change the label of x-axis to 'Infected (in thousands)', the label of y-axis to 'Death(in thousands)'.
  e. Change the title of the figure as 'Infected against death on 2020-11-01'.
  f. Save the plot to file 'q1.png'.

```{r fig.align='center', out.width= '75%', include = F, eval = F}
## 1. (a)
# df1 <- slid::state.long %>% dplyr::filter(DATE == all_of(d)) 
# df2 <- slid::state.long %>% dplyr::filter(DATE == all_of(d-14)) 
# df <- df1 %>% mutate(Infected.14daysAgo = df2$Infected)
# p <- ggplot(df, 
#             aes(x = (Infected.14daysAgo/pop) * 1000, 
#                 y = (Death/pop) * 1000)) +        
#             geom_point()   
df <- slid::state.long %>% 
  dplyr::filter(DATE == as.Date('2020-11-01'))

p <- ggplot(df, 
            aes(Infected / 1000, Death / 1000)) +         
            geom_point()  

# 1.(b) & (c)
p <- p + geom_point(aes(color = pop, size = pop)) +
   scale_color_gradient(low = "lightblue", high = "pink")+
   scale_size_area(max_size = 12) +
   guides(color = guide_legend(), size = guide_legend())

# (d) 
p <- p + xlab('Infected (in thousands)') + 
  ylab('Death(in thousands)')

# (e) 
p <- p + labs(title = 'Infected against death on 2020-11-01')

p 

ggsave('q1.png', p)
```

2. Time series plot using `slid::state.ts` for Florida. 
  a. Obtain the daily new death count for Florida.
  b. Create a line plot, time as x-axis, daily new death as y-axis. Add the title "Daily new death count for Florida" to the plot.
  c. Using the data up till 2020-11-27, a model obtained the following prediction and 80% prediction intervals for the period from 2020-11-28 to 2020-12-11. 

```  
    DATE   Y.Death    PI
1 2020-11-28   72  [33, 111]
2 2020-11-29   56  [17,  96]
3 2020-11-30   74  [34, 114]
4 2020-12-01   88  [48, 128]
5 2020-12-02   91  [50, 131]
6 2020-12-03   59  [18, 101]
7 2020-12-04  104  [62, 146]
8 2020-12-05   79  [31, 128]
9 2020-12-06   64  [14, 113]
10 2020-12-07  81  [31, 132]
11 2020-12-08  95  [43, 148]
12 2020-12-09  98  [44, 152]
13 2020-12-10  67  [12, 122]
14 2020-12-11 111  [54, 168]
```  
  Add another line on your time series plot indicating the predicted daily new death data. Change the title to "Two weeks ahead forecast of the daily new death count for Florida" your plot.
  
  d. Add ribbons on your time series plot in part c to illustrate the prediction intervals in part c. Change the title to "Two weeks ahead forecast of the daily new death count for Florida with 80% prediction intervals".
  
  e. Save the plot to file 'q2.png'.

3. For the data `slid::state.long` and focus on 2020-11-01, do the following:
  a. Create a map using Death per 1000 population as the coloring feature.
  b. Save the plot to file 'q3.png'.
  
4. Combine the three figures and save the plot to file 'q4.png'. 
  Hint: In `R`, save each plot with different names (e.g. `p1`, `p2`, `p3`), and then use the `patchwork` package.

```{r include = F, eval = F}
# Read map and data
library(ggplot2)
library(maps)
library(dplyr)

# Load United States state map data
MainStates <- map_data("state")

# read the state population data
StatePopulation <- 
  read.csv("https://raw.githubusercontent.com/ds4stats/r-tutorials/master/intro-maps/data/StatePopulation.csv", as.is = TRUE)

MergedStates <- 
  left_join(MainStates, StatePopulation, by = "region") %>% 
  mutate('state' = gsub('', '', MainStates$region)) %>%
  select(-c('region', 'subregion'))
head(MergedStates)

df <- slid::state.long %>% 
  mutate('state' = tolower(slid::state.long$State)) %>%
  right_join(MergedStates, by = 'state') %>%
  select(-state, -population, -elect_votes)

# saveRDS(df, 'state.long.shape.rda')

df <- df %>% dplyr::filter(DATE == '2020-12-11')
# df <- slid::ggplot_map_state

# df <- slid::state.long.shape %>% 
# dplyr::filter(DATE =='2020-12-11')
```


